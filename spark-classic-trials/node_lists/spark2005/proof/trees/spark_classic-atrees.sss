with SPARK_Classic.Expose_Nodes,
     SPARK_Classic.Trees,
     SPARK_Classic.Bounded_Stacks;
use type SPARK_Classic.Expose_Nodes.Tree_Node,
         SPARK_Classic.Expose_Nodes.Key_Type;
--# inherit SPARK_Classic.Expose_Nodes,
--#         SPARK_Classic.Trees,
--#         SPARK_Classic.Bounded_Stacks;
package SPARK_Classic.Atrees is
   subtype Key_Type is Expose_Nodes.Key_Type;
   subtype Value_Type is Expose_Nodes.Value_Type;
   subtype Tree_Node is Expose_Nodes.Tree_Node;
   Null_Value : constant Value_Type := Expose_Nodes.Null_Value;

   type A_Tree is tagged private;
   Null_A_Tree : constant A_Tree;
   
   subtype Element_Type is Bounded_Stacks.Element_Type;
   
   function Empty_Tree (Tree : A_Tree) return Boolean;

   function Populated (Tree : A_Tree; Tree_Store : Trees.Tree_Type)
      return Boolean;

   procedure New_Tree (Tree : out A_Tree);
   --# post Empty_Tree (Tree);

   function Count (Tree : A_Tree) return Natural;
   
   function Is_Present (Tree       : A_Tree;
                        Key        : Key_Type;
                        Tree_Store : Trees.Tree_Type) return Boolean;
   --# pre Populated (Tree, Tree_Store);
 
   --# function Persists (AT_Pre, AT_Post : A_Tree; 
   --#                    TS_Pre, TS_Post : Trees.Tree_Type) 
   --# return Boolean;
   --# pre Populated (AT_Pre, TS_Pre);
   --# return Populated (AT_Post, TS_Post) and
   --#        Trees.Persists (TS_Pre, TS_Post) and
   --#        Count (AT_Pre) = Count (AT_Post);
   
   procedure Insert (Tree       : in out A_Tree;
                     Key        : Key_Type;
                     Tree_Store : in out Trees.Tree_Type;
                     Inserted   : out Boolean);
   --# post Is_Present (Tree, Key, Tree_Store) and
   --#      Populated (Tree, Tree_Store) and
   --#      (Inserted -> (((not Populated (Tree~, Tree_Store~)) -> 
   --#                        Count (Tree) = 1) and
   --#                    ((Populated (Tree~, Tree_Store~)) -> 
   --#                        Count (Tree) = Count (Tree~) + 1)));

   procedure Insert_With_Value (Tree          : in out A_Tree;
                                Key           : Key_Type;
                                Value         : Value_Type;
                                Tree_Store    : in out Trees.Tree_Type;
                                Inserted      : out Boolean;
                                Value_At_Node : out Value_Type);
   --# post Is_Present (Tree, Key, Tree_Store) and
   --#      Populated (Tree, Tree_Store) and
   --#      (Inserted -> (((not Populated (Tree~, Tree_Store~)) -> 
   --#                        Count (Tree) = 1) and
   --#                    ((Populated (Tree~, Tree_Store~)) -> 
   --#                        Count (Tree) = Count (Tree~) + 1)));

   procedure Clear (Tree       : in out A_Tree;
                    Tree_Store : in out Trees.Tree_Type);
   --# pre not Empty_Tree (Tree);
   --# post Empty_Tree (Tree);

   function Is_Equal (Tree_1       : A_Tree;
                      Tree_2       : A_Tree;
                      Tree_Store_1 : Trees.Tree_Type;
                      Tree_Store_2 : Trees.Tree_Type) return Boolean;
   --# pre Populated (Tree_1, Tree_Store_1) and Populated (Tree_2, Tree_Store_2);
   --# return E => E -> Tree_1 = Tree_2;

   function Tree_Depth (Tree       : A_Tree;
                        Tree_Store : Trees.Tree_Type) return Natural;

   type Enumerator is private;

   function New_Enumerator (Tree       : A_Tree;
                            Tree_Store : Trees.Tree_Type) return Enumerator;
   --# pre Populated (Tree, Tree_Store);

   procedure Next_Node (E : in out Enumerator; Tree_Store : Trees.Tree_Type;
                        Node : out Tree_Node);

private
   type Enumerator is
      record
         Root    : A_Tree;
         --  A stack to record visited nodes when enumerating.
         Visited : Bounded_Stacks.Stack; 
      end record;
         

   type A_Tree is tagged
      record
         Root    : Tree_Node;
         Count   : Natural;
      end record;

   Null_A_Tree : constant A_Tree := A_Tree'
     (Root  => Trees.Empty_Node,
      Count => 0);


   type Direction is (Left, Right);

end SPARK_Classic.Atrees;
